package ast_parsers;

import java.util.ArrayList;
import java.util.List;

import ast_expr.ExprBuiltinFn;
import ast_expr.ExprExpression;
import ast_symtab.BuiltinNames;
import ast_types.Type;
import ast_types.TypeBindings;
import parse.Parse;
import tokenize.Ident;
import tokenize.T;
import tokenize.Token;

public class ParseBuiltinsFn {
  private final Parse parser;

  public ParseBuiltinsFn(Parse parser) {
    this.parser = parser;
  }

  public ExprExpression parse() {

    // builtin .
    final Token beginPos = parser.checkedMove(BuiltinNames.std_ident);
    parser.checkedMove(T.T_DOT);

    final Ident funcname = parser.getIdent();
    checkIsCorrectBuiltinIdent(funcname);

    if (funcname.equals(BuiltinNames.print_ident) || funcname.equals(BuiltinNames.assert_true_ident)) {
      final List<Type> typeArguments = new ArrayList<>();
      final List<ExprExpression> fcallArguments = parseArglist();
      final Type restype = new Type(beginPos);
      final ExprBuiltinFn builtinFn = new ExprBuiltinFn(funcname, typeArguments, fcallArguments, restype);
      return new ExprExpression(builtinFn, beginPos);
    }

    if (BuiltinNames.isBuiltinMemFuncIdent(funcname)) {

      final List<Type> typeArguments = new ParseType(parser).getTypeArguments();
      if (typeArguments.isEmpty()) {
        parser.perror("empty type-arguments in std.mem function");
      }

      final List<ExprExpression> fcallArguments = parseArglist();

      Type restype = typeArguments.get(0); ///TODO:pointers
      if (funcname.equals(BuiltinNames.mem_free_ident) || funcname.equals(BuiltinNames.mem_cpy_ident)) {
        restype = new Type(beginPos);
      }

      final ExprBuiltinFn builtinFn = new ExprBuiltinFn(funcname, typeArguments, fcallArguments, restype);
      parser.getCurrentClass(true).registerTypeSetter(builtinFn);
      return new ExprExpression(builtinFn, beginPos);
    }

    if (BuiltinNames.isFdIdent(funcname)) {
      Type restype = TypeBindings.make_int();
      final List<ExprExpression> fcallArguments = parseArglist();
      final ExprBuiltinFn builtinFn = new ExprBuiltinFn(funcname, new ArrayList<>(), fcallArguments, restype);
      return new ExprExpression(builtinFn, beginPos);
    }

    /// std.zero<T>() 
    /// this function will be expanded in call, which will return
    /// the address of static const struct which was
    /// generated by deffault for each class
    /// this is the null-replacement, actually not so clean by design,
    /// but more safe perhaps, or perhaps it is not :)
    ///
    if (funcname.equals(BuiltinNames.zero_ident)) {
      final List<Type> typeArguments = new ParseType(parser).getTypeArguments();
      if (typeArguments.size() != 1) {
        parser.perror("expected one type-argument for std.zero<T>() function");
      }

      final List<ExprExpression> fcallArguments = parseArglist();

      Type restype = typeArguments.get(0);
      final ExprBuiltinFn builtinFn = new ExprBuiltinFn(funcname, typeArguments, fcallArguments, restype);
      parser.getCurrentClass(true).registerTypeSetter(builtinFn);
      return new ExprExpression(builtinFn, beginPos);
    }

    parser.perror("unimplemented builtin function: " + funcname.toString());
    return null;
  }

  private void checkIsCorrectBuiltinIdent(Ident funcname) {
    if (!BuiltinNames.isCorrectBuiltinIdent(funcname)) {
      parser.perror("unimplemented builtin function: " + funcname.toString());
    }
  }

  private List<ExprExpression> parseArglist() {
    return new ParseFcallArgs(parser).parse();
  }

}
