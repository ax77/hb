import std.mem.malloc;

class node<T>
{
    weak var prev: node<T>;
    var item: T;
    var next: node<T>;
    
    init(prev: node<T>,
         item: T,
         next: node<T>)
    {
        self.prev = prev;
        self.next = next;
        self.item = item;
    }
}

class list<T>
{
    var first: node<T>;
    var last: node<T>;
    var size: i32;
    
    func push_back(e: T)
    {
        var l: node<T> = self.last;
        var n: node<T> = new node<T>(
            prev: l,
            item: e,
            next: null
        );
        self.last = n;
        if (l == null) {
            self.first = n;
        } else {
            l.next = n;
        }
        self.size += 1;
    }
    
    func get_iterator() -> list_iterator<T>
    {
        return new list_iterator<T>(
            collection: self
        );
    }
}

class list_iterator<T> {

    var collection: list<T>;
    var last_returned: node<T>;
    var next: node<T>;
    var next_index: i32;
    
    init(collection: list<T>)
    {
        self.collection = collection;
        self.last_returned = collection.first;
        self.next = collection.first;
        self.next_index = 0;
    }
    
    func get_current() -> T
    {
        return last_returned.item;
    }
    
    func has_next() -> boolean
    {
        return next_index < collection.size;
    }
    
    func get_next() -> T
    {
        self.last_returned = next;
        self.next = next.next;
        self.next_index += 1;
        return last_returned.item;
    }
}
