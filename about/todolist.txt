* static semantic
* unit tests
* GC
* opt<type> and 'null'
* init the parser with the string

* default methods: 
    equals 
    to_string 
    hash
    deepcopy 
    fill_property_values - this one is like a copy constructor

* package semantic: std.natives.some_class is a full name of a class
    std.natives.some_class.func1 -> is a full name of a function of this class
    std.natives.some_class.func2 -> ...

*[V] gen cast expression
* string concatenation
* const variables in generated file!
* annotations (method, field, class, etc)
* cast expression types compatibility

*[V] maybe add some compile-time macros like __FILE__, __LINE__, are they useful? 
    I think that they are.
    we do not have a preprocessor, so it's quite easy to implement these macros.
    just change the type of parsed token at lexer stage, that's it.
  
* destructors for tests methods

* modifiers -> all variables are final by-default, we need a mut modifier
    and then - apply this to code-generator, it will help the
    compiler optimize the result code.

*[V] add string methods (left, right, etc)
*[V] fix string constructor code generation [new string("a.b.c")]

* error codes, and pretty error printing, equal for every situation.
  | file:line
  | error [code]: [message]
  | to_string
  
  Here's a thing: we must keep our AST.toString() clean during the parse state.
  It must print its real representation.
  Without any c-code semantic (like types, pointers, etc.)
  And we have to manage a different ToString class, when we build a low-level code.
  So: we use toString() in classes only during the parse stage.
  And then - we implement our own toString() for each type, class, method, etc.



